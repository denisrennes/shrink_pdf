#!/usr/bin/env bash

# Try to shrink the size of PDF files, using a Ghostscript command. See: https://www.digitalocean.com/community/tutorials/reduce-pdf-file-size-in-linux
# All arguments are PDF files to shrink. They can be passed by a file manager custom context menu actions, like Nemo actions.

# If the size of the PDF file has actually been reduced (at least 1 % shrinked), then the original file is renamed ‘.ORIGINAL.pdf’ and the new compressed file takes its name.
# If the PDF file could not be reduced in size, it means it is already optimized. This tool will detect this and display a message, leaving the original PDF file unchanged.

# For translations
. gettext.sh
export TEXTDOMAIN="$(basename "$0")"
TEXTDOMAINDIR="$(cd "$(dirname "$0")" && pwd)/locale"
if [ ! -d ${TEXTDOMAINDIR} ]; then
    TEXTDOMAINDIR="/usr/share/locale"
fi
export TEXTDOMAINDIR


##### FUNCTIONS and basic initialization #####

# it will be a "press any key" prompt before any exit, until the script arguments are parsed for the --press_any_key option
press_any_key=true

# Colors and highligh in outputs
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BOLD=$(tput bold)
RESET=$(tput sgr0)

ERR="${RED}${BOLD}"
OK="${GREEN}${BOLD}"
WARN="${YELLOW}${BOLD}"
HIGHLIGHT="${BOLD}"

# Display a given message then waits for any key to be pressed, then return
# $1: Optional message to display. Default: "Press any key...'"
function press_any_key () {
    echo
    if [[ -z ${1} ]]; then
        echo -n "$(eval_gettext "\${HIGHLIGHT}Press any key...\${RESET}")"
    else
        echo -n "${1}"
    fi
    read -s -n 1
    echo
}

# Exit this script with an exit code, possibly after a "press any key"
function exit_script () {
    local exit_message
    if [[ -z ${2} ]]; then
        exit_message="$(eval_gettext "\${HIGHLIGHT}Press any key to finish...\${RESET}")"
    else
        exit_message="${2}"
    fi
    if [ ${press_any_key} = true ]; then press_any_key "${exit_message}"; fi

    if [[ -z ${1} ]]; then
        exit 255
    else
        exit ${1}
    fi
}

# number of files having failed to be shrinked by 'gs' (could be due to this file, so non-fatal failure, process continued to the next file)
nb_file_failed=0


# File base name, with the extension, if any
# $1 is the file path
# Result is returned via stdout
function file_name () {
    echo "${1##*/}"
}

# File Extension, if any. Example: '.pdf' 
# $1 is the file path
# Result is returned via stdout
# A '.' as first character of the file name is discarded for the search of the file extension. Ex: '.conf': no extension, '.conf.json':'.json' extension 
# When no extension, '' is returned
function file_extension () {
    local filename

    # Extract filename from path
    filename="$(file_name "${1}")"

    # If filename starts with a dot, remove it: it does not mean an extension
    if [[ "$filename" == .* ]]; then
        filename="${filename##.}"
    fi

    # If filename contains a dot, extract the extension
    if [[ "$filename" == *.* ]]; then
        echo ".${filename##*.}"
    else
        echo ''
    fi
}

# Removes the extension of a file path (the starting '.' is removed too)
# $1 is the file path
# Result is returned via stdout
function path_without_extension () {
    local file=${1}
    local ext="$(file_extension "${file}")"      # the file extension
    # remove the n last characters, n is file extension length
    if [[ -z ${ext} ]]; then 
        echo "${file}"
    else
        echo "${file::-$((${#ext}))}"
    fi
}

# Divide a number by 1000 with a required number of digits after the decimal point
# $1 is the number to divide by 1000
# $2 is the required number of digits after the decimal point
# Return the result to the Standard Output
function divide_by_1000 () {
    if (( $# != 2 )); then
        return 255
    fi
    echo "scale=$2; $1/1000" | bc -l
}

# Compute the shrink percentage
# $1 is the original size
# $2 is the new size
# Return the result to the Standard Output
# Example: return "96.8" if $1 is 5808000 and $2 is 184000
function shrink_percent () {
    if (( $# != 2 )); then
        return 255
    fi
    echo "scale=1; 100-$2*100/$1" | bc -l
}



##### MAIN ####


# Error exit if "gs" is not installed (Ghostscript command)
command -v gs  1>/dev/null 2>&1 || {
    echo "$(eval_gettext "\${ERR}ERROR: The \"gs\" command is required but not installed. (Ghostscript)\${RESET}" )" 1>&2
    exit_script 1
}

# Error exit if "bc" is not installed (Basic Calculator)
command -v bc  1>/dev/null 2>&1 || {
    echo "$(eval_gettext "\${ERR}ERROR: The \"bc\" command is required but not installed. (Basic Calulator)\${RESET}" )" 1>&2
    exit_script 1
}


# parsing arguments: "--press_any_key" or a file path
press_any_key=false
files=()
for arg in "$@"; do
    case "$arg" in
        --press_any_key)
            press_any_key=true
            ;;
        --* | -*)
            echo "$(eval_gettext "\${ERR}ERROR: Incorrect command line argument \"\${arg}\".\${RESET}" )" 1>&2
            exit_script 1
            ;;
        *)
            files+=("$arg")
            ;;
    esac
done


TEMP_SHRINKED_SUBEXT="$(gettext ".TEMP_SHRINKED")"      # The temporary name of the shrinked file will end with ".TEMP_SHRINKED.pdf"
ORIGINAL_SUBEXT="$(gettext ".ORIGINAL")"                # "bak" file name: the new name of the original PDF file will end with ".ORIGINAL.pdf"

# Process every file provided as arguments
for input_file in "${files[@]}"
do
    echo

    file_extension="$(file_extension "${input_file}")"                  # file extension
    filepath_minus_ext="$(path_without_extension "${input_file}")"      # input file path without extension

    # normal case: the input file has NOT been already processed and renamed by this script
    result_file="${filepath_minus_ext}${TEMP_SHRINKED_SUBEXT}${file_extension}"     # The temporary name of the result file. It will be later renamed as the original source file name.
    bak_file=${filepath_minus_ext}${ORIGINAL_SUBEXT}${file_extension}               # The future name of the original PDF file (It will be renamed if the shrinking is successful)
    
    # file names for shorter output messages
    input_file_filename="$(file_name "${input_file}")"
    bak_file_filename="$(file_name "${bak_file}")"

    echo -n ">>> ${HIGHLIGHT}${input_file_filename}${RESET} <<< "

    # Skip the file if its corresponding original file (renamed as a "bak" file) exists in the same directory
    if [[ -f "${bak_file}" ]]; then
        msg="$( eval_gettext "\${WARN}SKIPPED\${RESET} because it is probably the shrinking result of \"\${bak_file_filename}\"" )"
        echo "${msg}"
        continue        # next file
    fi

    # Skip the file if it is a file already renamed .${ORIGINAL_SUBEXT}${file_extension}): it is an original file previously processed by this script.
    extension2="$(file_extension "${filepath_minus_ext}")"      # second extension
    if [[ "${extension2}" == "${ORIGINAL_SUBEXT}" ]]; then
        echo "$( eval_gettext "\${WARN}SKIPPED\${RESET} because it has been already shrinked before. To shrink it again, rename it: remove \"\${ORIGINAL_SUBEXT}\"." )"
        continue        # next file
    fi

    filesize_input_file=$(stat -c%s "${input_file}")                        # size of the original file
    filesize_input_file_kB="$(divide_by_1000 ${filesize_input_file} 1)"     # size of the original file in kB
    
    # if the result file already exists (with its temporary name), then delete it. It could be the result of a previous shrinking attempt, interrupted before the renaming step.
    if [[ -f "${result_file}" ]]; then
        rm "${result_file}"
        if (($? != 0 )); then
            echo "$( eval_gettext "\${ERR}ERROR: unable to delete \"\${result_file}\" before starting shrinking. Check access rights.\${RESET}" )" 1>&2
            exit_script 1
        fi
    fi

    # Use a Ghostscript command to shrink the PDF file
    # The result file could be even smaller by using the argument “-dPDFSETTINGS=/screen,” though with a higher loss of quality (that many still consider acceptable).
    gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile="${result_file}" "${input_file}"  1>/dev/null 2>&1
    exit_code=$?

    # if the exit code is not 0 then display an error, delete the temporary result file (if any), then continue with the next file
    if (( ${exit_code} != 0 )); then
        echo "$( eval_gettext "\${ERR}ERROR: The shrinking command failed and returned an error. Most likely this is not a valid PDF file.\${RESET}" )" 1>&2
        # if the result file exists, delete it because it is probably corrupted (it happens sometimes with 'gs')
        if [[ -f "${result_file}" ]]; then
            rm "${result_file}"  1>/dev/null
            if (($? != 0 )); then
                echo "$( eval_gettext "\${ERR}ERROR: something went wrong trying to delete the result file. Check access rights.\${RESET}" )" 1>&2
            fi
        fi
        ((nb_file_failed+=1))       # non-fatal failure: could be due to the file itself, so we continue to the next file
        continue   # next file
    fi
    # if the result temporay file does not exist, display an error, then continue with the next file
    if [[ ! -f "${result_file}" ]]; then
        echo "$( eval_gettext "\${ERR}ERROR: something went wrong, no shrinking result file.\${RESET}" )"
        exit_script 1
    fi

    # Verify that the result file is at least 1% smaller than the original: 
    # if so, rename the source file as a "bak" file and the result file will replace it, taking its name, 
    # else delete the result file: the source file was already small
    filesize_result_file=$(stat -c%s "${result_file}")                              # size of the result file
    filesize_result_file_kB="$(divide_by_1000 ${filesize_result_file} 1)"           # size of the result file in kB
    shrink_percent="$(shrink_percent ${filesize_input_file} ${filesize_result_file})"    # shrink percentage


    if (( $(echo "$shrink_percent < 1" | bc -l) )); then
    
        # The shrink percentage is less than 1%. Moreover it might be negative, meaning the result file is bigger
        echo "$( eval_gettext "\${WARN}NOT shrinked:\${RESET} most likely this file is already as small as possible." )"

        # Delete the result file
        rm "${result_file}"  1>/dev/null
        if (($? == 0 )); then
            continue    # next file
        else 
            echo "$( eval_gettext "\${ERR}ERROR: something went wrong trying to delete the result file. Check access rights.\${RESET}" )" 1>&2
            ((nb_file_failed+=1))       # non-fatal failure: could be due to the file itself, so we continue to the next file
            continue   # next file
        fi

    fi

    # Successful shrinking: renaming steps

    # rename the source file as a "bak" file (.ORIGINAL in English)
    mv "${input_file}" "${bak_file}"
    if (($? != 0 )); then
        echo "$( eval_gettext "\${ERR}ERROR: something went wrong after shrinking. Unable to rename the original file as \"\${bak_file}\". Check access rights.\${RESET}" )" 1>&2
        ((nb_file_failed+=1))       # non-fatal failure: could be due to the file itself, so we continue to the next file
        continue
    fi

    # rename the result file as the original file name    
    mv "${result_file}" "${input_file}"
    if (($? != 0 )); then
        echo "$( eval_gettext "\${ERR}ERROR: something went wrong after shrinking. Unable to rename the temporary result file name \"\${result_file}\" as the original file name. Check access rights.\${RESET}" )" 1>&2
        ((nb_file_failed+=1))       # non-fatal failure: could be due to the file itself, so we continue to the next file
        continue
    fi

    echo "$( eval_gettext "\${OK}\${shrink_percent} % shrinked.\${RESET}  (Original: \"\${bak_file_filename}\")" )"
    
done
    
# End message
echo
if (( nb_file_failed > 0)); then
    echo "$( eval_ngettext \
    "\${ERR}ERROR: \${nb_file_failed} file with error during the shrinking process or the renaming after shrinking.\${RESET}" \
    "\${ERR}ERROR: \${nb_file_failed} files with errors during the shrinking process or the renaming after shrinking.\${RESET}" \
    "$nb_file_failed" )"
else
    echo "$(eval_gettext "\${OK}OKAY.\${RESET}")"
fi

exit_script 0 "$(eval_gettext "\${HIGHLIGHT}Press any key to finish...\${RESET}")"
